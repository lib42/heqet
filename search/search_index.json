{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Heqet \u00b6 Heqet (Egyptian \u1e25qt, also \u1e25qtyt \"Heqtit\") is an Egyptian goddess of fertility. Heqet is my attempt to make Kubernetes GitOps Deployments as easy as possible. It's goal is to reduce the need of redundant configuration in a GitOps environment, by generating the required Kubernetes resource definitions for you. Heqet heavily relies on a Helm-Chart which will generate all ArgoCD-Applications, -Projects, Namespaces & more using Argo-CDs App-of-Apps-Pattern . What problem does heqet solve? \u00b6 Kubernetes allows declarative infrastructure which can be stored in git easily. Argo-CD is used to deploy those configurations. With Argo-CD it's simple to deploy Helm-Charts. But you still need to write a lot of redundant yaml-files. Heqet reduces the configuration required to deploy Helm-chart-based applications to the bare minimum: What's the name of your app? Which Chart to deploy? Which values to apply? Deploy it! Making GitOps based deployments simple while keeping kubernetes power & customizability. Keyfeatures \u00b6 Easy Setup [Just requires Kubernetes + Argo-CD] Simple / DRY application definition & configuration Follows the GitOps principles Deploy a whole application environment or cluster from a singe git-repo Addons for simple generation of VaultSecret and NetworkPolicy resources Include reuseable resources like value snippets & NetworkPolicies into your app Inheritance of configuration options [defaults -> project -> app] Overview \u00b6 Components & Configuration \u00b6 Core component is Argo-CD which will deploy Heqet & also your apps! All you need is a git-repo & k8s cluster. The heqet Configuration-Management-Plugin [CMP] will generate ArgoCD-Applications & -Projects, Namespaces and if required VaultSecret s, NetworkPolicies , Argo-CD Repositories and more. Filestructure \u00b6 Heqet is highly opinionated about it's structure. It helps you keeping multiple projects organized. The user configuration is organized like this: /projects/ - This directory contains all your Application/Project config /projects/name-of-project/ - This directory name represents the name of our project /projects/name-of-project/project.yaml - The most important config, containing all our applications & project config /projects/name-of-project/values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml /projects/name-of-project/values/name-of-app.yaml - Values file for the application \"name-of-app\" /projects/name-of-project/manifests/ - Static yaml manifests for your app /resources/ - This directory contains all global config, like NetworkPolcies, Repos /resources/manifests/ - Can be used for static YAML-Manifests, like CRD's and other global configurations /resources/snippets/ - Value snippets for your apps Installation \u00b6 Installing heqet is quite simple: Install Argo-CD version >= 2.2.0 on your cluster & set it up to your needs Configure Argo-CD Plugin Create your heqet userdata git repository Configure manifests/heqet-apps.yaml to match your Setup kubectl apply -f manifests/heqet-apps.yaml Create your configuration in projects and resources folders Example Configuration \u00b6 - Name - - Description - Hive-Apps My Homelab configuration Docs \u00b6 Check out the full documentation: here","title":"Heqet"},{"location":"#heqet","text":"Heqet (Egyptian \u1e25qt, also \u1e25qtyt \"Heqtit\") is an Egyptian goddess of fertility. Heqet is my attempt to make Kubernetes GitOps Deployments as easy as possible. It's goal is to reduce the need of redundant configuration in a GitOps environment, by generating the required Kubernetes resource definitions for you. Heqet heavily relies on a Helm-Chart which will generate all ArgoCD-Applications, -Projects, Namespaces & more using Argo-CDs App-of-Apps-Pattern .","title":"Heqet"},{"location":"#what-problem-does-heqet-solve","text":"Kubernetes allows declarative infrastructure which can be stored in git easily. Argo-CD is used to deploy those configurations. With Argo-CD it's simple to deploy Helm-Charts. But you still need to write a lot of redundant yaml-files. Heqet reduces the configuration required to deploy Helm-chart-based applications to the bare minimum: What's the name of your app? Which Chart to deploy? Which values to apply? Deploy it! Making GitOps based deployments simple while keeping kubernetes power & customizability.","title":"What problem does heqet solve?"},{"location":"#keyfeatures","text":"Easy Setup [Just requires Kubernetes + Argo-CD] Simple / DRY application definition & configuration Follows the GitOps principles Deploy a whole application environment or cluster from a singe git-repo Addons for simple generation of VaultSecret and NetworkPolicy resources Include reuseable resources like value snippets & NetworkPolicies into your app Inheritance of configuration options [defaults -> project -> app]","title":"Keyfeatures"},{"location":"#overview","text":"","title":"Overview"},{"location":"#components-configuration","text":"Core component is Argo-CD which will deploy Heqet & also your apps! All you need is a git-repo & k8s cluster. The heqet Configuration-Management-Plugin [CMP] will generate ArgoCD-Applications & -Projects, Namespaces and if required VaultSecret s, NetworkPolicies , Argo-CD Repositories and more.","title":"Components &amp; Configuration"},{"location":"#filestructure","text":"Heqet is highly opinionated about it's structure. It helps you keeping multiple projects organized. The user configuration is organized like this: /projects/ - This directory contains all your Application/Project config /projects/name-of-project/ - This directory name represents the name of our project /projects/name-of-project/project.yaml - The most important config, containing all our applications & project config /projects/name-of-project/values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml /projects/name-of-project/values/name-of-app.yaml - Values file for the application \"name-of-app\" /projects/name-of-project/manifests/ - Static yaml manifests for your app /resources/ - This directory contains all global config, like NetworkPolcies, Repos /resources/manifests/ - Can be used for static YAML-Manifests, like CRD's and other global configurations /resources/snippets/ - Value snippets for your apps","title":"Filestructure"},{"location":"#installation","text":"Installing heqet is quite simple: Install Argo-CD version >= 2.2.0 on your cluster & set it up to your needs Configure Argo-CD Plugin Create your heqet userdata git repository Configure manifests/heqet-apps.yaml to match your Setup kubectl apply -f manifests/heqet-apps.yaml Create your configuration in projects and resources folders","title":"Installation"},{"location":"#example-configuration","text":"- Name - - Description - Hive-Apps My Homelab configuration","title":"Example Configuration"},{"location":"#docs","text":"Check out the full documentation: here","title":"Docs"},{"location":"filestructure/","text":"Filestructure \u00b6 Heqet is highly opinionated about the filestructure of the userdata repository. Here is a quick overview how it should look like: Heqetfile - Important config file for ArgoCD/heqet. See Heqetfile projects/ - This directory contains all your Application/Project config name-of-project/ - This directory name represents the name of our project project.yaml - The most important config, containing all our applications of this project values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml name-of-app.yaml - Values file for the application \"name-of-app\" manifests/ - Static YAML-files for the project resources/ - This directory contains all global config, like NetworkPolcies, Repos manifests/ - Can be used for static YAML-Manifests snippets/ - Value snippets that can be included using include -Array in apps Overview \u00b6","title":"Filestructure"},{"location":"filestructure/#filestructure","text":"Heqet is highly opinionated about the filestructure of the userdata repository. Here is a quick overview how it should look like: Heqetfile - Important config file for ArgoCD/heqet. See Heqetfile projects/ - This directory contains all your Application/Project config name-of-project/ - This directory name represents the name of our project project.yaml - The most important config, containing all our applications of this project values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml name-of-app.yaml - Values file for the application \"name-of-app\" manifests/ - Static YAML-files for the project resources/ - This directory contains all global config, like NetworkPolcies, Repos manifests/ - Can be used for static YAML-Manifests snippets/ - Value snippets that can be included using include -Array in apps","title":"Filestructure"},{"location":"filestructure/#overview","text":"","title":"Overview"},{"location":"getting-started/","text":"Getting Started \u00b6 Argo-CD Configuration Management Plugin \u00b6 Heqet is basically not more then a hacky helm-chart. But to make it's configuration easier & more structured, i needed a way to split the chart from your custom values [or \"userdata\"]. Since version 2.2.0 Argo-CD supports \"Configuration Management Plugins\" [CMP] using sidecar containers. Heqet is utilizing this feature by injecting a sidecar-container into Argo-CD's repo-server pod. The CMP will take care of keeping Heqets code and your userdata up-to-date. Thanks to this great feature of Argo-CD, your custom configuration & heqet's helm chart can be updated independantly. Example Configuration using Argo-CD Helm-Chart \u00b6 In this example we are using the official Argo-CD Helm Chart : Here is a incomplere snippet from the values.yaml : repoServer: # We'll need these for the sidecar injection to work: volumes: - name: var-files emptyDir: {} - name: plugins emptyDir: {} # Shared plugin directory volumeMounts: - mountPath: /home/argocd/cmp-server/plugins name: plugins # This copies the CMP-Server for the sidecar initContainers: - name: copy-cmp-server image: quay.io/argoproj/argocd:latest command: - cp - -n - /usr/local/bin/argocd - /var/run/argocd/argocd-cmp-server volumeMounts: - mountPath: /var/run/argocd name: var-files # Heqet Sidecar: extraContainers: - name: cmp-heqet command: [/var/run/argocd/argocd-cmp-server] image: lib42/heqet-cli:latest securityContext: runAsNonRoot: true runAsUser: 999 volumeMounts: - mountPath: /var/run/argocd name: var-files - mountPath: /home/argocd/cmp-server/plugins name: plugins - mountPath: /tmp name: tmp-dir Notice: Make sure the repo-server & sidecar use the same /tmp-volume! Creating your userdata git repository \u00b6 When the CMP is setup, it's time to deploy your first app using heqet. For this you'll need a \"userdata\"-repo. For an example, check out my homelab config: hive-apps One important file is the Heqetfile . It's required to make the CMP work & will be used to determine which heqet-version / branch to use. Example Heqetfile: # Heqetfile heqet_repo=https://github.com/lib42/heqet.git heqet_revision=v3 heqet_path=charts/heqet heqet_values=values.yaml Normally you wouldn't need to change these options unless you want to use your own fork of heqet. See also Heqetfile Creating a new project \u00b6 Copy the example/project folder to charts/heqet/projects/name-of-your-project . It contains a template for the project.yaml and also the values directory. In the values directory you can simple create a new .yaml file, this the name of the app it belongs to. [same name as defined in the project.yaml by you.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#argo-cd-configuration-management-plugin","text":"Heqet is basically not more then a hacky helm-chart. But to make it's configuration easier & more structured, i needed a way to split the chart from your custom values [or \"userdata\"]. Since version 2.2.0 Argo-CD supports \"Configuration Management Plugins\" [CMP] using sidecar containers. Heqet is utilizing this feature by injecting a sidecar-container into Argo-CD's repo-server pod. The CMP will take care of keeping Heqets code and your userdata up-to-date. Thanks to this great feature of Argo-CD, your custom configuration & heqet's helm chart can be updated independantly.","title":"Argo-CD Configuration Management Plugin"},{"location":"getting-started/#example-configuration-using-argo-cd-helm-chart","text":"In this example we are using the official Argo-CD Helm Chart : Here is a incomplere snippet from the values.yaml : repoServer: # We'll need these for the sidecar injection to work: volumes: - name: var-files emptyDir: {} - name: plugins emptyDir: {} # Shared plugin directory volumeMounts: - mountPath: /home/argocd/cmp-server/plugins name: plugins # This copies the CMP-Server for the sidecar initContainers: - name: copy-cmp-server image: quay.io/argoproj/argocd:latest command: - cp - -n - /usr/local/bin/argocd - /var/run/argocd/argocd-cmp-server volumeMounts: - mountPath: /var/run/argocd name: var-files # Heqet Sidecar: extraContainers: - name: cmp-heqet command: [/var/run/argocd/argocd-cmp-server] image: lib42/heqet-cli:latest securityContext: runAsNonRoot: true runAsUser: 999 volumeMounts: - mountPath: /var/run/argocd name: var-files - mountPath: /home/argocd/cmp-server/plugins name: plugins - mountPath: /tmp name: tmp-dir Notice: Make sure the repo-server & sidecar use the same /tmp-volume!","title":"Example Configuration using Argo-CD Helm-Chart"},{"location":"getting-started/#creating-your-userdata-git-repository","text":"When the CMP is setup, it's time to deploy your first app using heqet. For this you'll need a \"userdata\"-repo. For an example, check out my homelab config: hive-apps One important file is the Heqetfile . It's required to make the CMP work & will be used to determine which heqet-version / branch to use. Example Heqetfile: # Heqetfile heqet_repo=https://github.com/lib42/heqet.git heqet_revision=v3 heqet_path=charts/heqet heqet_values=values.yaml Normally you wouldn't need to change these options unless you want to use your own fork of heqet. See also Heqetfile","title":"Creating your userdata git repository"},{"location":"getting-started/#creating-a-new-project","text":"Copy the example/project folder to charts/heqet/projects/name-of-your-project . It contains a template for the project.yaml and also the values directory. In the values directory you can simple create a new .yaml file, this the name of the app it belongs to. [same name as defined in the project.yaml by you.","title":"Creating a new project"},{"location":"helm-plugin/","text":"Heqet Helm Plugin \u00b6 A helm plugin for templating heqet configuration into kubernetes resources. It can also be used to e.g. validate your configuration or for CI/CD. This plugin is part of Heqet . Installation \u00b6 > helm plugin install https://github.com/lib42/helm-heqet.git Usage \u00b6 Important: All commands must be executed inside your heqet project, with a Heqetfile in the current working directory! helm heqet setup : Clones heqet & insert your configuration helm heqet update : Updates heqet after setup helm heqet template : Templates the Heqet Chart with your config helm heqet validate : Simple syntax validation test helm heqet generate : Combination of update & template [for CI/CD usage] helm heqet help : print help Example \u00b6 > helm heqet setup > helm heqet template Container Image \u00b6 Additionally there is a container image containing the plugin: lib42/heqet-cli","title":"Helm Plugin"},{"location":"helm-plugin/#heqet-helm-plugin","text":"A helm plugin for templating heqet configuration into kubernetes resources. It can also be used to e.g. validate your configuration or for CI/CD. This plugin is part of Heqet .","title":"Heqet Helm Plugin"},{"location":"helm-plugin/#installation","text":"> helm plugin install https://github.com/lib42/helm-heqet.git","title":"Installation"},{"location":"helm-plugin/#usage","text":"Important: All commands must be executed inside your heqet project, with a Heqetfile in the current working directory! helm heqet setup : Clones heqet & insert your configuration helm heqet update : Updates heqet after setup helm heqet template : Templates the Heqet Chart with your config helm heqet validate : Simple syntax validation test helm heqet generate : Combination of update & template [for CI/CD usage] helm heqet help : print help","title":"Usage"},{"location":"helm-plugin/#example","text":"> helm heqet setup > helm heqet template","title":"Example"},{"location":"helm-plugin/#container-image","text":"Additionally there is a container image containing the plugin: lib42/heqet-cli","title":"Container Image"},{"location":"overview/","text":"Overview \u00b6 This page gives you a quick overview about the main components & terminology of heqet. Apps \u00b6 Apps are Helm-Charts to deploy. Every app is part of a Project & needs to be listed in the apps -list inside the project.yaml . Every app will become an Argo-CD Application -CRD. The Application s configuration can be changed on a global base inside the values.yaml , at project level inside the project.yaml or on app level inside the app definition. Projects \u00b6 Projects are collections of Apps. Every project will become a Namespace and a Argo-CD Project. The name of the project, namespace and project will depend on the name of the project-directory but can also be configured in the project.yaml . Projects can also contain NetworkPolicies and static manifests usind the manifests folder inside the project directory. Resources \u00b6 Resources or also called \"Addons\" or \"Generators\" are additional helper functions that can create additinal Kubernetes resources like NetworkPolicy s or VaultSecrets . Eg. NetworkPolicies can be predefined, grouped & later applied in multiple apps. NetworkPolicies [networkpolicy.yaml] \u00b6 Config \u00b6 The NetworkPolicy-Addon has a few global configuration options. Like which polcies to apply by default & if the communication inside a Namespace should always be allowed. networkPolicy: config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true default: groups: [] rules: [] Policies \u00b6 NetworkPolicies are defined in the Kubernetes spec, but inside a dict networkPolicy.rules : networkPolicy: rules: allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {} allow-ingress: podSelector: {} policyTypes: - Ingress ingress: - from: - namespaceSelector: matchLabels: app.heqet.gnu.one/name: ingress-external Notice: Heqet will apply annotations to every namespace e.g. app.heqet.gnu.one/name containing the name of the app. This way we can easily predefine policies that apply on a specific app. Groups \u00b6 Now comes the heqet magic! NetworkPolcies can be grouped and groups of NetworkPolcies can be applied to Projects. networkPolicy: groups: internet: - allow-dns - allow-proxy - allow-ingress rules: allow-dns: [...] allow-proxy: [...] allow-ingress: [...] config: description: Gitea Git Server networkPolicy: groups: - internet rules: - allow-ssh Snippets \u00b6 Value snippets can be used, when multiple apps use the same value structure. A good example for this are the charts by the K8s-at-home project . Here's an example for resources/snippets/noRoot.yaml : securityContext: runAsNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false capabilities: drop: - ALL Once create we can include this snippet into out app like this [ project.yaml ]: config: [...] apps: - name: my-app include: - noRoot Repos \u00b6 We can add Helm-Chart repositories to Argo-CD like this: [ resources/repos.yaml ] # Parameters: # name-of-repo: # url: https://... # type: [default: helm | git] # repos: argo: url: https://argoproj.github.io/argo-helm bitnami: url: https://charts.bitnami.com/bitnami k8s-at-home: url: https://k8s-at-home.com/charts These repos can also be applied to projects or apps. In this example my-app uses the bitnami -repo, while another-app uses the projects default repo k8s-at-home . [ project.yaml ]: config: repo: k8s-at-home apps: - name: my-app repo: bitnami - name: another-app","title":"Overview"},{"location":"overview/#overview","text":"This page gives you a quick overview about the main components & terminology of heqet.","title":"Overview"},{"location":"overview/#apps","text":"Apps are Helm-Charts to deploy. Every app is part of a Project & needs to be listed in the apps -list inside the project.yaml . Every app will become an Argo-CD Application -CRD. The Application s configuration can be changed on a global base inside the values.yaml , at project level inside the project.yaml or on app level inside the app definition.","title":"Apps"},{"location":"overview/#projects","text":"Projects are collections of Apps. Every project will become a Namespace and a Argo-CD Project. The name of the project, namespace and project will depend on the name of the project-directory but can also be configured in the project.yaml . Projects can also contain NetworkPolicies and static manifests usind the manifests folder inside the project directory.","title":"Projects"},{"location":"overview/#resources","text":"Resources or also called \"Addons\" or \"Generators\" are additional helper functions that can create additinal Kubernetes resources like NetworkPolicy s or VaultSecrets . Eg. NetworkPolicies can be predefined, grouped & later applied in multiple apps.","title":"Resources"},{"location":"overview/#networkpolicies-networkpolicyyaml","text":"","title":"NetworkPolicies [networkpolicy.yaml]"},{"location":"overview/#config","text":"The NetworkPolicy-Addon has a few global configuration options. Like which polcies to apply by default & if the communication inside a Namespace should always be allowed. networkPolicy: config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true default: groups: [] rules: []","title":"Config"},{"location":"overview/#policies","text":"NetworkPolicies are defined in the Kubernetes spec, but inside a dict networkPolicy.rules : networkPolicy: rules: allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {} allow-ingress: podSelector: {} policyTypes: - Ingress ingress: - from: - namespaceSelector: matchLabels: app.heqet.gnu.one/name: ingress-external Notice: Heqet will apply annotations to every namespace e.g. app.heqet.gnu.one/name containing the name of the app. This way we can easily predefine policies that apply on a specific app.","title":"Policies"},{"location":"overview/#groups","text":"Now comes the heqet magic! NetworkPolcies can be grouped and groups of NetworkPolcies can be applied to Projects. networkPolicy: groups: internet: - allow-dns - allow-proxy - allow-ingress rules: allow-dns: [...] allow-proxy: [...] allow-ingress: [...] config: description: Gitea Git Server networkPolicy: groups: - internet rules: - allow-ssh","title":"Groups"},{"location":"overview/#snippets","text":"Value snippets can be used, when multiple apps use the same value structure. A good example for this are the charts by the K8s-at-home project . Here's an example for resources/snippets/noRoot.yaml : securityContext: runAsNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false capabilities: drop: - ALL Once create we can include this snippet into out app like this [ project.yaml ]: config: [...] apps: - name: my-app include: - noRoot","title":"Snippets"},{"location":"overview/#repos","text":"We can add Helm-Chart repositories to Argo-CD like this: [ resources/repos.yaml ] # Parameters: # name-of-repo: # url: https://... # type: [default: helm | git] # repos: argo: url: https://argoproj.github.io/argo-helm bitnami: url: https://charts.bitnami.com/bitnami k8s-at-home: url: https://k8s-at-home.com/charts These repos can also be applied to projects or apps. In this example my-app uses the bitnami -repo, while another-app uses the projects default repo k8s-at-home . [ project.yaml ]: config: repo: k8s-at-home apps: - name: my-app repo: bitnami - name: another-app","title":"Repos"},{"location":"addons/","text":"Addons \u00b6 Heqet contains a \"addon\" feature which will create additional resources for you or further simplefy configuration by abstraction.","title":"Addons"},{"location":"addons/#addons","text":"Heqet contains a \"addon\" feature which will create additional resources for you or further simplefy configuration by abstraction.","title":"Addons"},{"location":"addons/networkpolicy/","text":"NetworkPolicy \u00b6 NetworkPolicies allow you to control/deny access to or from your application. If you want to learn how NetworkPolices work, check out the Kubernetes documentation . Define Rules \u00b6 Next you can create/predefine NetworkPolices in resources/networkpolicy.yaml like this: networkrPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: [] rules: [] # NetworkPolices can be grouped: groups: [] # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress This rule will deny all out- [Egress] and Ingoing [Ingress] network traffic. We can define more rules ofcurse [even if 'deny-everything' is already included in 'allow-dns']: networkPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: - insecure rules: [] # NetworkPolices can be grouped: groups: insecure: - deny-everything - allow-dns # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {} This will create a group of both of our rules & apply them by default to all projects. Apply NetworkPolicies \u00b6 Finally we can apply the NetworkPolicy to our application project. Currently Heqet is not able to apply NetworkPolcies only to a single App of an project! from project.yaml : config: name: secure-project description: I like it secure! networkPolicy: rules: - deny-everything - allow-dns groups: - special-group apps: - name: my-secure-app [...] Allow communication between Heqet projects \u00b6 Here is a simple way to apply rules containing other heqet apps. Lets say we have two apps: config: name: project-one networkPolicy: rules: - deny-project-two apps: [...] So we want to deny access from project-one to project-two . In this case we can use a label that's automatically applied by heqet to every application namespace: app.heqet.gnu.one/project Our policy could look something like this: networkPolicy: rules: deny-project-two: podSelector: {} policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: app.heqet.gnu.one/project: project-two","title":"NetworkPolicy"},{"location":"addons/networkpolicy/#networkpolicy","text":"NetworkPolicies allow you to control/deny access to or from your application. If you want to learn how NetworkPolices work, check out the Kubernetes documentation .","title":"NetworkPolicy"},{"location":"addons/networkpolicy/#define-rules","text":"Next you can create/predefine NetworkPolices in resources/networkpolicy.yaml like this: networkrPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: [] rules: [] # NetworkPolices can be grouped: groups: [] # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress This rule will deny all out- [Egress] and Ingoing [Ingress] network traffic. We can define more rules ofcurse [even if 'deny-everything' is already included in 'allow-dns']: networkPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: - insecure rules: [] # NetworkPolices can be grouped: groups: insecure: - deny-everything - allow-dns # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {} This will create a group of both of our rules & apply them by default to all projects.","title":"Define Rules"},{"location":"addons/networkpolicy/#apply-networkpolicies","text":"Finally we can apply the NetworkPolicy to our application project. Currently Heqet is not able to apply NetworkPolcies only to a single App of an project! from project.yaml : config: name: secure-project description: I like it secure! networkPolicy: rules: - deny-everything - allow-dns groups: - special-group apps: - name: my-secure-app [...]","title":"Apply NetworkPolicies"},{"location":"addons/networkpolicy/#allow-communication-between-heqet-projects","text":"Here is a simple way to apply rules containing other heqet apps. Lets say we have two apps: config: name: project-one networkPolicy: rules: - deny-project-two apps: [...] So we want to deny access from project-one to project-two . In this case we can use a label that's automatically applied by heqet to every application namespace: app.heqet.gnu.one/project Our policy could look something like this: networkPolicy: rules: deny-project-two: podSelector: {} policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: app.heqet.gnu.one/project: project-two","title":"Allow communication between Heqet projects"},{"location":"addons/repos/","text":"Repositories \u00b6 Heqet can add Helm & Git repositories to Argo-CD & resolve the repoURL in your config for you. Private repos are not supported [yet]. Configuration \u00b6 Here is a simple example of the configuration file resources/repos.yml : # Dict of helm or git repos we want to add to ArgoCD # Parameters: # name-of-repo: # url: https://... # type: [default: helm | git] # repos: bitnami: url: https://charts.bitnami.com/bitnami ## default: helm #type: helm heqet: url: https://git.nold.in/nold/heqet type: git Using Repos \u00b6 Here is a snipped from a project.yml : config: name: myproject apps: - name: myapp repo: bitnami chart: superappchart As you might guess, the option repo: bitnami gets resolved to the url in our repos configuration.","title":"Repositories"},{"location":"addons/repos/#repositories","text":"Heqet can add Helm & Git repositories to Argo-CD & resolve the repoURL in your config for you. Private repos are not supported [yet].","title":"Repositories"},{"location":"addons/repos/#configuration","text":"Here is a simple example of the configuration file resources/repos.yml : # Dict of helm or git repos we want to add to ArgoCD # Parameters: # name-of-repo: # url: https://... # type: [default: helm | git] # repos: bitnami: url: https://charts.bitnami.com/bitnami ## default: helm #type: helm heqet: url: https://git.nold.in/nold/heqet type: git","title":"Configuration"},{"location":"addons/repos/#using-repos","text":"Here is a snipped from a project.yml : config: name: myproject apps: - name: myapp repo: bitnami chart: superappchart As you might guess, the option repo: bitnami gets resolved to the url in our repos configuration.","title":"Using Repos"},{"location":"addons/vault/","text":"VaultSecret Generator \u00b6 The VaultSecret generator will create a VaultSecret for every secret specified in the secrets -hash. It's based on the vault-secret-operator . Parameters \u00b6 Parameter Type Example Description name string \"my-secret\" Name of Secret to generate & in vault [requited] keys array[string] - password Array of keys that will be pulled from the vault-secret [required] type string Opaque Secret type in Kubernetes [default: Opaque ] fromApp string myapp2 Pulls secret from another app, e.g. /heqet/<other-app>/<secret.name> . This way sharing secrets between apps is easily possible Examples \u00b6 Simple \u00b6 Here is an example for a simple secret: apps: - name: myapp secrets: - name: my-secret keys: - username - password # default: type: Opaque This will result in following resource. Notice that the path inside of Vault is /heqet/<name-of-app>/<name-of-secret> . apiVersion: ricoberger.de/v1alpha1 kind: VaultSecret metadata: name: my-secret namespace: \"myapp\" labels: app: myapp annotations: argocd.argoproj.io/sync-wave: \"-1\" spec: keys: - username - password path: heqet/myapp/my-secret type: Opaque Sharing Secrets between Apps \u00b6 Secrets can also be shared & pulled from other apps, by using the fromApp parameter: apps: - name: myapp secrets: - name: my-secret keys: - username - password - shared-key # default: type: Opaque - name: myapp2 secrets: - name: my-secret fromApp: myapp keys: - shared-key","title":"VaultSecret Generator"},{"location":"addons/vault/#vaultsecret-generator","text":"The VaultSecret generator will create a VaultSecret for every secret specified in the secrets -hash. It's based on the vault-secret-operator .","title":"VaultSecret Generator"},{"location":"addons/vault/#parameters","text":"Parameter Type Example Description name string \"my-secret\" Name of Secret to generate & in vault [requited] keys array[string] - password Array of keys that will be pulled from the vault-secret [required] type string Opaque Secret type in Kubernetes [default: Opaque ] fromApp string myapp2 Pulls secret from another app, e.g. /heqet/<other-app>/<secret.name> . This way sharing secrets between apps is easily possible","title":"Parameters"},{"location":"addons/vault/#examples","text":"","title":"Examples"},{"location":"addons/vault/#simple","text":"Here is an example for a simple secret: apps: - name: myapp secrets: - name: my-secret keys: - username - password # default: type: Opaque This will result in following resource. Notice that the path inside of Vault is /heqet/<name-of-app>/<name-of-secret> . apiVersion: ricoberger.de/v1alpha1 kind: VaultSecret metadata: name: my-secret namespace: \"myapp\" labels: app: myapp annotations: argocd.argoproj.io/sync-wave: \"-1\" spec: keys: - username - password path: heqet/myapp/my-secret type: Opaque","title":"Simple"},{"location":"addons/vault/#sharing-secrets-between-apps","text":"Secrets can also be shared & pulled from other apps, by using the fromApp parameter: apps: - name: myapp secrets: - name: my-secret keys: - username - password - shared-key # default: type: Opaque - name: myapp2 secrets: - name: my-secret fromApp: myapp keys: - shared-key","title":"Sharing Secrets between Apps"},{"location":"config/Heqetfile/","text":"Heqetfile \u00b6 The Heqetfile is a control file for the ArgoCD/helm Plugin and crutial to make heqet work. Mostly it defines which heqet version to use and which values.yaml as default values for your projects. Example \u00b6 Here is a simple yet complete example of a Heqetfile . Make sure to place it in the root directory of your git repository. # Heqetfile # # _repo & _revision define the source & branch/tag to checkout # _path is the path to the heqet chart inside of the repo # heqet_repo=https://github.com/lib42/heqet.git heqet_revision=v3 heqet_path=charts/heqet heqet_values=values.yaml","title":"Heqetfile"},{"location":"config/Heqetfile/#heqetfile","text":"The Heqetfile is a control file for the ArgoCD/helm Plugin and crutial to make heqet work. Mostly it defines which heqet version to use and which values.yaml as default values for your projects.","title":"Heqetfile"},{"location":"config/Heqetfile/#example","text":"Here is a simple yet complete example of a Heqetfile . Make sure to place it in the root directory of your git repository. # Heqetfile # # _repo & _revision define the source & branch/tag to checkout # _path is the path to the heqet chart inside of the repo # heqet_repo=https://github.com/lib42/heqet.git heqet_revision=v3 heqet_path=charts/heqet heqet_values=values.yaml","title":"Example"},{"location":"config/application/","text":"Application Config \u00b6 Required \u00b6 Parameter Type Example Description name string \"argocd\" Name of your application & namespace [if not specified] repoURL string \"https://github.com/nold360/heqet\" URL to git or Helmchart repo or repo string \"heqet\" Name of a predefinied Helm/Git-Repo path string \"charts/heqet\" Path to chart if using git as source repo chart string \"heqet\" Chart name [ only use either path or chart ] targetRevision string \"1.2.3\" or \"master\" Version of Helm-Chart or Branch/Tag of git Optional \u00b6 Parameter Type Default Example Description existingNamespace string none \"default\" Don't create namespace, instead use an existing one namespace string Namespace of project \"superns\" Name of application namespace annotations hash my.anno.org/stuff: is-awesome Kubernetes Resource annotations syncWave string \"0\" `\"-2\" ArgoCD SyncWave server string \"https://kubernetes.default.svc\" https://my.external.cluster:8443 K8s Cluster to deploy to automated.prune bool false true ArgoCD automatic prune app automated.selfHeal bool false true ArgoCD automatic self-heal app ignoreDiff array See ArgoCD docs ArgoCD ignoreDifferences parameters array - name: ingress.host value: awesome.url Parameters override values of app include array - value-snippet Include a values snippet from resources/snippets Full Example \u00b6 Check out the hive -Branch of this repo for my current homelab setup.","title":"Application Config"},{"location":"config/application/#application-config","text":"","title":"Application Config"},{"location":"config/application/#required","text":"Parameter Type Example Description name string \"argocd\" Name of your application & namespace [if not specified] repoURL string \"https://github.com/nold360/heqet\" URL to git or Helmchart repo or repo string \"heqet\" Name of a predefinied Helm/Git-Repo path string \"charts/heqet\" Path to chart if using git as source repo chart string \"heqet\" Chart name [ only use either path or chart ] targetRevision string \"1.2.3\" or \"master\" Version of Helm-Chart or Branch/Tag of git","title":"Required"},{"location":"config/application/#optional","text":"Parameter Type Default Example Description existingNamespace string none \"default\" Don't create namespace, instead use an existing one namespace string Namespace of project \"superns\" Name of application namespace annotations hash my.anno.org/stuff: is-awesome Kubernetes Resource annotations syncWave string \"0\" `\"-2\" ArgoCD SyncWave server string \"https://kubernetes.default.svc\" https://my.external.cluster:8443 K8s Cluster to deploy to automated.prune bool false true ArgoCD automatic prune app automated.selfHeal bool false true ArgoCD automatic self-heal app ignoreDiff array See ArgoCD docs ArgoCD ignoreDifferences parameters array - name: ingress.host value: awesome.url Parameters override values of app include array - value-snippet Include a values snippet from resources/snippets","title":"Optional"},{"location":"config/application/#full-example","text":"Check out the hive -Branch of this repo for my current homelab setup.","title":"Full Example"},{"location":"config/project/","text":"Project Definition \u00b6 Here is a list of available configuration options inside the apps array of heqets values.yaml . Project Config \u00b6 Project configuration parameters will be merged into application parameters. So basically all application parameters can be used here. Special project parameters: Parameter Type Default Example Description name string Name of project directory my-project Name of project in Argo-CD namespace string Name of project myspace Name of default Namespace of projects apps description string None \"My great project\" Description of project in Argo-CD networkPolicy dict None See addons/networkpolicy","title":"Project Definition"},{"location":"config/project/#project-definition","text":"Here is a list of available configuration options inside the apps array of heqets values.yaml .","title":"Project Definition"},{"location":"config/project/#project-config","text":"Project configuration parameters will be merged into application parameters. So basically all application parameters can be used here. Special project parameters: Parameter Type Default Example Description name string Name of project directory my-project Name of project in Argo-CD namespace string Name of project myspace Name of default Namespace of projects apps description string None \"My great project\" Description of project in Argo-CD networkPolicy dict None See addons/networkpolicy","title":"Project Config"},{"location":"misc/vault/","text":"Vault \u00b6 This are some quick notes I took on how to setup a simple Vault for usage with heqet. For a more detailed documentation on how to configure Vault, check out the Official Vault Docs . Note: Most of this commands can be executed either using the vault command on your local device or the inside the vault pod itself. Init Vault using GPG \u00b6 Copy GPG Public Key \u00b6 cat > nold.pub << EOF -----BEGIN PGP PUBLIC KEY BLOCK----- mQENBGBXTjkBCAC7qZU1cz7RWYbAb838ypRLJZKLWfVBvry4XYwWPN0Rcj55dPN+ ... 5of4H66FzNwJxYrunmM5KTeUxZiLPC1JoKMF5uvKoo59TD0IuAPq735QDjWbS4vb dMtSqTCinZSd =wuZw -----END PGP PUBLIC KEY BLOCK----- EOF Init Vault \u00b6 vault operator init -key-shares=1 -key-threshold=1 -pgp-keys=\"nold.pub\" Save Unseal Key somewhere sage e.g. Keepass \u00b6 Decode Unseal Key \u00b6 $ echo $unseal-key | base64 -d | gpg -dq Unseal Vault \u00b6 vault operator unseal Enable Kubernetes Auth \u00b6 vault auth enable kubernetes vault write auth/kubernetes/config \\ token_reviewer_jwt=\"$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\ kubernetes_host=\"https://$KUBERNETES_PORT_443_TCP_ADDR:443\" \\ kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\ disable_iss_validation=true Create Secret Store \u00b6 vault secrets enable -path=heqet kv-v2 Add Secrets-Operator Role & Policy \u00b6 Create Policy \u00b6 vault policy write heqet-app << EOF path \"heqet/+/*\" { capabilities = [\"read\"] } EOF Add Auth Role \u00b6 vault write auth/kubernetes/role/heqet-app \\ bound_service_account_names=vault-secrets-operator \\ bound_service_account_namespaces=vault-secrets-operator \\ policies=heqet-app \\ ttl=6h Add Secrets \u00b6 Remember, Secret path: heqet/<APP-NAME>/<SECRET-NAME> vault kv put heqet/argocd/argocd-secret admin.password='$2y$12$FP8OlsVj5pOOqRAhI4XPoev1STaW01uUEZGcNPQtVZmpacebNhj9i' server.secretkey=\"pDYAWK2mHa68GwwVPAsQOsG/SUT8iIo3S3FXYUWf2qM=\" vault kv put heqet/loki-stack/loki-stack-grafana admin-user=admin admin-password='grafana' vault kv put heqet/pihole/pihole-admin password=pihole vault kv put heqet/minio/minio-secret secret-key=secret access-key=access Vault-Issuer Cert-Manager via Kubernetes Service Account \u00b6 We expect you already have setup a PKI & Intermediate PKI. You will need a policy to allow your approle to create new certs: And a role: [dc = my local domain] vault write pki_int/roles/dc \\ allowed_domains=.dc \\ allow_subdomains=true \\ max_ttl=72h Policy: vault policy write pki_int - <<EOF path \"pki_int*\" { capabilities = [\"read\", \"list\"] } path \"pki_int/roles/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/sign/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/issue/dc\" { capabilities = [\"create\"] } EOF Authorize Service Account vault write auth/kubernetes/role/vault-issuer \\ bound_service_account_names=vault-issuer \\ bound_service_account_namespaces=cert-manager \\ policies=pki_int \\ ttl=6h","title":"Vault"},{"location":"misc/vault/#vault","text":"This are some quick notes I took on how to setup a simple Vault for usage with heqet. For a more detailed documentation on how to configure Vault, check out the Official Vault Docs . Note: Most of this commands can be executed either using the vault command on your local device or the inside the vault pod itself.","title":"Vault"},{"location":"misc/vault/#init-vault-using-gpg","text":"","title":"Init Vault using GPG"},{"location":"misc/vault/#copy-gpg-public-key","text":"cat > nold.pub << EOF -----BEGIN PGP PUBLIC KEY BLOCK----- mQENBGBXTjkBCAC7qZU1cz7RWYbAb838ypRLJZKLWfVBvry4XYwWPN0Rcj55dPN+ ... 5of4H66FzNwJxYrunmM5KTeUxZiLPC1JoKMF5uvKoo59TD0IuAPq735QDjWbS4vb dMtSqTCinZSd =wuZw -----END PGP PUBLIC KEY BLOCK----- EOF","title":"Copy GPG Public Key"},{"location":"misc/vault/#init-vault","text":"vault operator init -key-shares=1 -key-threshold=1 -pgp-keys=\"nold.pub\"","title":"Init Vault"},{"location":"misc/vault/#save-unseal-key-somewhere-sage-eg-keepass","text":"","title":"Save Unseal Key somewhere sage e.g. Keepass"},{"location":"misc/vault/#decode-unseal-key","text":"$ echo $unseal-key | base64 -d | gpg -dq","title":"Decode Unseal Key"},{"location":"misc/vault/#unseal-vault","text":"vault operator unseal","title":"Unseal Vault"},{"location":"misc/vault/#enable-kubernetes-auth","text":"vault auth enable kubernetes vault write auth/kubernetes/config \\ token_reviewer_jwt=\"$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\ kubernetes_host=\"https://$KUBERNETES_PORT_443_TCP_ADDR:443\" \\ kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\ disable_iss_validation=true","title":"Enable Kubernetes Auth"},{"location":"misc/vault/#create-secret-store","text":"vault secrets enable -path=heqet kv-v2","title":"Create Secret Store"},{"location":"misc/vault/#add-secrets-operator-role-policy","text":"","title":"Add Secrets-Operator Role &amp; Policy"},{"location":"misc/vault/#create-policy","text":"vault policy write heqet-app << EOF path \"heqet/+/*\" { capabilities = [\"read\"] } EOF","title":"Create Policy"},{"location":"misc/vault/#add-auth-role","text":"vault write auth/kubernetes/role/heqet-app \\ bound_service_account_names=vault-secrets-operator \\ bound_service_account_namespaces=vault-secrets-operator \\ policies=heqet-app \\ ttl=6h","title":"Add Auth Role"},{"location":"misc/vault/#add-secrets","text":"Remember, Secret path: heqet/<APP-NAME>/<SECRET-NAME> vault kv put heqet/argocd/argocd-secret admin.password='$2y$12$FP8OlsVj5pOOqRAhI4XPoev1STaW01uUEZGcNPQtVZmpacebNhj9i' server.secretkey=\"pDYAWK2mHa68GwwVPAsQOsG/SUT8iIo3S3FXYUWf2qM=\" vault kv put heqet/loki-stack/loki-stack-grafana admin-user=admin admin-password='grafana' vault kv put heqet/pihole/pihole-admin password=pihole vault kv put heqet/minio/minio-secret secret-key=secret access-key=access","title":"Add Secrets"},{"location":"misc/vault/#vault-issuer-cert-manager-via-kubernetes-service-account","text":"We expect you already have setup a PKI & Intermediate PKI. You will need a policy to allow your approle to create new certs: And a role: [dc = my local domain] vault write pki_int/roles/dc \\ allowed_domains=.dc \\ allow_subdomains=true \\ max_ttl=72h Policy: vault policy write pki_int - <<EOF path \"pki_int*\" { capabilities = [\"read\", \"list\"] } path \"pki_int/roles/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/sign/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/issue/dc\" { capabilities = [\"create\"] } EOF Authorize Service Account vault write auth/kubernetes/role/vault-issuer \\ bound_service_account_names=vault-issuer \\ bound_service_account_namespaces=cert-manager \\ policies=pki_int \\ ttl=6h","title":"Vault-Issuer Cert-Manager via Kubernetes Service Account"}]}