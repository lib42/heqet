{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Heqet \u00b6 Heqet (Egyptian \u1e25qt, also \u1e25qtyt \"Heqtit\") is an Egyptian goddess of fertility. Heqet is my attempt to make Kubernetes GitOps Deployments as easy as possible. It's goal is to reduce the need of redundant configuration in a GitOps environment, by generating the required Kubernetes resource definitions for you. Heqet heavily relies on a Helm-Chart which will generate all ArgoCD-Applications, -Projects, Namespaces & more using Argo-CDs App-of-Apps-Pattern . What problem does heqet solve? \u00b6 Kubernetes allows declarative infrastructure which can be stored in git easily. Argo-CD is used to deploy those configurations. With Argo-CD it's simple to deploy Helm-Charts. But you still need to write a lot of redundant yaml-files. Heqet reduces the configuration required to deploy Helm-chart-based applications to the bare minimum: - What's the name of your app? - Which Chart to deploy? - Which values to apply? - Do it! Keyfeatures \u00b6 Easy Setup [Just requires Kubernetes + Argo-CD] Simple / DRY application definition & configuration Follows the GitOps principles Deploy a whole application environment or cluster from a singe git-repo Addons for simple generation of VaultSecret and NetworkPolicy resources Include reuseable resources like value snippets & NetworkPolicies into your app Inheritance of configuration options [defaults -> project -> app] Overview \u00b6 Components & Configuration \u00b6 Core component is Argo-CD which will deploy Heqet & also your apps! All you need is a git-repo & k8s cluster. The heqet Configuration-Management-Plugin [CMP] will generate ArgoCD-Applications & -Projects, Namespaces and if required VaultSecret s, NetworkPolicies , Argo-CD Repositories and more. The user configuration is seperated in different files & directories: projects/ - This directory contains all your Application/Project config name-of-project/ - This directory name represents the name of our project project.yaml - The most important config, containing all our applications of this project values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml name-of-app.yaml - Values file for the application \"name-of-app\" manifests/ - Static yaml manifests for your app resources/ - This directory contains all global config, like NetworkPolcies, Repos manifests/ - Can be used for static YAML-Manifests snippets/ - Value snippets for your apps Installation \u00b6 Installing heqet is quite simple: Install Argo-CD version >= 2.2.0 on your cluster & set it up to your needs Configure Argo-CD Plugin Create your heqet userdata git repository Configure manifests/heqet-apps.yaml to match your Setup kubectl apply -f manifests/heqet-apps.yaml Create your configuration in projects and resources folders Example Configuration \u00b6 FIXME Docs \u00b6 Check out the full documentation: here","title":"Heqet"},{"location":"#heqet","text":"Heqet (Egyptian \u1e25qt, also \u1e25qtyt \"Heqtit\") is an Egyptian goddess of fertility. Heqet is my attempt to make Kubernetes GitOps Deployments as easy as possible. It's goal is to reduce the need of redundant configuration in a GitOps environment, by generating the required Kubernetes resource definitions for you. Heqet heavily relies on a Helm-Chart which will generate all ArgoCD-Applications, -Projects, Namespaces & more using Argo-CDs App-of-Apps-Pattern .","title":"Heqet"},{"location":"#what-problem-does-heqet-solve","text":"Kubernetes allows declarative infrastructure which can be stored in git easily. Argo-CD is used to deploy those configurations. With Argo-CD it's simple to deploy Helm-Charts. But you still need to write a lot of redundant yaml-files. Heqet reduces the configuration required to deploy Helm-chart-based applications to the bare minimum: - What's the name of your app? - Which Chart to deploy? - Which values to apply? - Do it!","title":"What problem does heqet solve?"},{"location":"#keyfeatures","text":"Easy Setup [Just requires Kubernetes + Argo-CD] Simple / DRY application definition & configuration Follows the GitOps principles Deploy a whole application environment or cluster from a singe git-repo Addons for simple generation of VaultSecret and NetworkPolicy resources Include reuseable resources like value snippets & NetworkPolicies into your app Inheritance of configuration options [defaults -> project -> app]","title":"Keyfeatures"},{"location":"#overview","text":"","title":"Overview"},{"location":"#components-configuration","text":"Core component is Argo-CD which will deploy Heqet & also your apps! All you need is a git-repo & k8s cluster. The heqet Configuration-Management-Plugin [CMP] will generate ArgoCD-Applications & -Projects, Namespaces and if required VaultSecret s, NetworkPolicies , Argo-CD Repositories and more. The user configuration is seperated in different files & directories: projects/ - This directory contains all your Application/Project config name-of-project/ - This directory name represents the name of our project project.yaml - The most important config, containing all our applications of this project values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml name-of-app.yaml - Values file for the application \"name-of-app\" manifests/ - Static yaml manifests for your app resources/ - This directory contains all global config, like NetworkPolcies, Repos manifests/ - Can be used for static YAML-Manifests snippets/ - Value snippets for your apps","title":"Components &amp; Configuration"},{"location":"#installation","text":"Installing heqet is quite simple: Install Argo-CD version >= 2.2.0 on your cluster & set it up to your needs Configure Argo-CD Plugin Create your heqet userdata git repository Configure manifests/heqet-apps.yaml to match your Setup kubectl apply -f manifests/heqet-apps.yaml Create your configuration in projects and resources folders","title":"Installation"},{"location":"#example-configuration","text":"FIXME","title":"Example Configuration"},{"location":"#docs","text":"Check out the full documentation: here","title":"Docs"},{"location":"Filestructure/","text":"Directory & Filestructure \u00b6 projects/ - This directory contains all your Application/Project config name-of-project/ - This directory name represents the name of our project project.yaml - The most important config, containing all our applications of this project values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml name-of-app.yaml - Values file for the application \"name-of-app\" manifests/ - Static YAML-files for the project resources/ - This directory contains all global config, like NetworkPolcies, Repos manifests/ - Can be used for static YAML-Manifests snippets/ - Value snippets that can be included using include -Array in apps Overview \u00b6","title":"Directory & Filestructure"},{"location":"Filestructure/#directory-filestructure","text":"projects/ - This directory contains all your Application/Project config name-of-project/ - This directory name represents the name of our project project.yaml - The most important config, containing all our applications of this project values/ - Every app in our project can have it's own values.yaml here, named: name-of-app.yaml name-of-app.yaml - Values file for the application \"name-of-app\" manifests/ - Static YAML-files for the project resources/ - This directory contains all global config, like NetworkPolcies, Repos manifests/ - Can be used for static YAML-Manifests snippets/ - Value snippets that can be included using include -Array in apps","title":"Directory &amp; Filestructure"},{"location":"Filestructure/#overview","text":"","title":"Overview"},{"location":"Getting-Started/","text":"Getting Started \u00b6 Argo-CD Configuration Management Plugin \u00b6 Heqet is basically not more then a hacky helm-chart. But to make it's configuration easier & more structured, i needed a way to split the chart from your custom values [or \"userdata\"]. Since version 2.2.0 Argo-CD supports \"Configuration Management Plugins\" [CMP] using sidecar containers. Heqet is utilizing this feature by injecting a sidecar-container into Argo-CD's repo-server pod. The CMP will take care of keeping Heqets code and your userdata up-to-date. Thanks to this great feature of Argo-CD, your custom configuration & heqet's helm chart can be updated independantly. Example Configuration using Argo-CD Helm-Chart \u00b6 In this example we are using the official Argo-CD Helm Chart : Here is a incomplere snippet from the values.yaml : repoServer: # We'll need these for the sidecar injection to work: volumes: - name: var-files emptyDir: {} - name: plugins emptyDir: {} # Shared plugin directory volumeMounts: - mountPath: /home/argocd/cmp-server/plugins name: plugins # This copies the CMP-Server for the sidecar initContainers: - name: copy-cmp-server image: quay.io/argoproj/argocd:latest command: - cp - -n - /usr/local/bin/argocd - /var/run/argocd/argocd-cmp-server volumeMounts: - mountPath: /var/run/argocd name: var-files # Heqet Sidecar: extraContainers: - name: cmp-heqet command: [/var/run/argocd/argocd-cmp-server] image: lib42/heqet-cli:latest securityContext: runAsNonRoot: true runAsUser: 999 volumeMounts: - mountPath: /var/run/argocd name: var-files - mountPath: /home/argocd/cmp-server/plugins name: plugins - mountPath: /tmp name: tmp-dir Notice: Make sure the repo-server & sidecar use the same /tmp-volume! Creating your userdata git repository \u00b6 When the CMP is setup, it's time to deploy your first app using heqet. For this you'll need a \"userdata\"-repo. For an example, check out my homelab config: hive-apps One important file is the Heqetfile . It's required to make the CMP work & will be used to determine which heqet-version / branch to use. Example Heqetfile: # Heqetfile heqet_repo=https://github.com/lib42/heqet.git heqet_revision=v3 heqet_path=charts/heqet heqet_values=values.yaml Normally you wouldn't need to change these options unless you want to use your own fork of heqet. Creating a new project \u00b6 Copy the example/project folder to charts/heqet/projects/name-of-your-project . It contains a template for the project.yaml and also the values directory. In the values directory you can simple create a new .yaml file, this the name of the app it belongs to. [same name as defined in the project.yaml by you.","title":"Getting Started"},{"location":"Getting-Started/#getting-started","text":"","title":"Getting Started"},{"location":"Getting-Started/#argo-cd-configuration-management-plugin","text":"Heqet is basically not more then a hacky helm-chart. But to make it's configuration easier & more structured, i needed a way to split the chart from your custom values [or \"userdata\"]. Since version 2.2.0 Argo-CD supports \"Configuration Management Plugins\" [CMP] using sidecar containers. Heqet is utilizing this feature by injecting a sidecar-container into Argo-CD's repo-server pod. The CMP will take care of keeping Heqets code and your userdata up-to-date. Thanks to this great feature of Argo-CD, your custom configuration & heqet's helm chart can be updated independantly.","title":"Argo-CD Configuration Management Plugin"},{"location":"Getting-Started/#example-configuration-using-argo-cd-helm-chart","text":"In this example we are using the official Argo-CD Helm Chart : Here is a incomplere snippet from the values.yaml : repoServer: # We'll need these for the sidecar injection to work: volumes: - name: var-files emptyDir: {} - name: plugins emptyDir: {} # Shared plugin directory volumeMounts: - mountPath: /home/argocd/cmp-server/plugins name: plugins # This copies the CMP-Server for the sidecar initContainers: - name: copy-cmp-server image: quay.io/argoproj/argocd:latest command: - cp - -n - /usr/local/bin/argocd - /var/run/argocd/argocd-cmp-server volumeMounts: - mountPath: /var/run/argocd name: var-files # Heqet Sidecar: extraContainers: - name: cmp-heqet command: [/var/run/argocd/argocd-cmp-server] image: lib42/heqet-cli:latest securityContext: runAsNonRoot: true runAsUser: 999 volumeMounts: - mountPath: /var/run/argocd name: var-files - mountPath: /home/argocd/cmp-server/plugins name: plugins - mountPath: /tmp name: tmp-dir Notice: Make sure the repo-server & sidecar use the same /tmp-volume!","title":"Example Configuration using Argo-CD Helm-Chart"},{"location":"Getting-Started/#creating-your-userdata-git-repository","text":"When the CMP is setup, it's time to deploy your first app using heqet. For this you'll need a \"userdata\"-repo. For an example, check out my homelab config: hive-apps One important file is the Heqetfile . It's required to make the CMP work & will be used to determine which heqet-version / branch to use. Example Heqetfile: # Heqetfile heqet_repo=https://github.com/lib42/heqet.git heqet_revision=v3 heqet_path=charts/heqet heqet_values=values.yaml Normally you wouldn't need to change these options unless you want to use your own fork of heqet.","title":"Creating your userdata git repository"},{"location":"Getting-Started/#creating-a-new-project","text":"Copy the example/project folder to charts/heqet/projects/name-of-your-project . It contains a template for the project.yaml and also the values directory. In the values directory you can simple create a new .yaml file, this the name of the app it belongs to. [same name as defined in the project.yaml by you.","title":"Creating a new project"},{"location":"k3s/","text":"Heqet on K3s \u00b6 Bootstrap K3s \u00b6 See: K3s Install Options Or if you are feeling lucky: curl -sfL https://get.k3s.io | sh - Bootstrap ArgoCD using Helm \u00b6 kubectl apply -f manifests/argocd-helm.yaml --- apiVersion: v1 kind: Namespace metadata: name: argocd --- apiVersion: helm.cattle.io/v1 kind: HelmChart metadata: name: argocd namespace: kube-system spec: chart: argo-cd repo: https://argoproj.github.io/argo-helm targetNamespace: argocd set: configs.secret.argocdServerAdminPassword: \"$2y$10$IuaM9Ad1mPMycjnStOdNc.wjRlLtI8448F/hS.eA0XJLH9r/ZwRv.\" valuesContent: |- controller: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true dex: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true redis: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true server: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true ingress: enabled: true hosts: - argocd.k3s extraArgs: - --insecure reposerver: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true The password in this example is argocd . Bootstrap Heqet \u00b6 kubectl apply -f manifests/heqet-apps.yaml --- apiVersion: v1 kind: Namespace metadata: name: heqet --- apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: heqet namespace: argocd spec: destination: namespace: heqet server: 'https://kubernetes.default.svc' source: path: . repoURL: 'https://github.com/nold360/heqet' targetRevision: test helm: valueFiles: - values.yaml project: default syncPolicy: automated: prune: true selfHeal: false Profit! \u00b6 Now K3s should be setup: ArgoCD should be deployed by K3s-Helm-Operator The Heqet-Application will bootstrap ArgoCD ArgoCD will take control of all Application configuration in heqet","title":"Heqet on K3s"},{"location":"k3s/#heqet-on-k3s","text":"","title":"Heqet on K3s"},{"location":"k3s/#bootstrap-k3s","text":"See: K3s Install Options Or if you are feeling lucky: curl -sfL https://get.k3s.io | sh -","title":"Bootstrap K3s"},{"location":"k3s/#bootstrap-argocd-using-helm","text":"kubectl apply -f manifests/argocd-helm.yaml --- apiVersion: v1 kind: Namespace metadata: name: argocd --- apiVersion: helm.cattle.io/v1 kind: HelmChart metadata: name: argocd namespace: kube-system spec: chart: argo-cd repo: https://argoproj.github.io/argo-helm targetNamespace: argocd set: configs.secret.argocdServerAdminPassword: \"$2y$10$IuaM9Ad1mPMycjnStOdNc.wjRlLtI8448F/hS.eA0XJLH9r/ZwRv.\" valuesContent: |- controller: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true dex: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true redis: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true server: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true ingress: enabled: true hosts: - argocd.k3s extraArgs: - --insecure reposerver: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true The password in this example is argocd .","title":"Bootstrap ArgoCD using Helm"},{"location":"k3s/#bootstrap-heqet","text":"kubectl apply -f manifests/heqet-apps.yaml --- apiVersion: v1 kind: Namespace metadata: name: heqet --- apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: heqet namespace: argocd spec: destination: namespace: heqet server: 'https://kubernetes.default.svc' source: path: . repoURL: 'https://github.com/nold360/heqet' targetRevision: test helm: valueFiles: - values.yaml project: default syncPolicy: automated: prune: true selfHeal: false","title":"Bootstrap Heqet"},{"location":"k3s/#profit","text":"Now K3s should be setup: ArgoCD should be deployed by K3s-Helm-Operator The Heqet-Application will bootstrap ArgoCD ArgoCD will take control of all Application configuration in heqet","title":"Profit!"},{"location":"vault/","text":"Vault \u00b6 This are some quick notes I took on how to setup a simple Vault for usage with heqet. For a more detailed documentation on how to configure Vault, check out the Official Vault Docs . Note: Most of this commands can be executed either using the vault command on your local device or the inside the vault pod itself. Init Vault using GPG \u00b6 Copy GPG Public Key \u00b6 cat > nold.pub << EOF -----BEGIN PGP PUBLIC KEY BLOCK----- mQENBGBXTjkBCAC7qZU1cz7RWYbAb838ypRLJZKLWfVBvry4XYwWPN0Rcj55dPN+ ... 5of4H66FzNwJxYrunmM5KTeUxZiLPC1JoKMF5uvKoo59TD0IuAPq735QDjWbS4vb dMtSqTCinZSd =wuZw -----END PGP PUBLIC KEY BLOCK----- EOF Init Vault \u00b6 vault operator init -key-shares=1 -key-threshold=1 -pgp-keys=\"nold.pub\" Save Unseal Key somewhere sage e.g. Keepass \u00b6 Decode Unseal Key \u00b6 $ echo $unseal-key | base64 -d | gpg -dq Unseal Vault \u00b6 vault operator unseal Enable Kubernetes Auth \u00b6 vault auth enable kubernetes vault write auth/kubernetes/config \\ token_reviewer_jwt=\"$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\ kubernetes_host=\"https://$KUBERNETES_PORT_443_TCP_ADDR:443\" \\ kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\ disable_iss_validation=true Create Secret Store \u00b6 vault secrets enable -path=heqet kv-v2 Add Secrets-Operator Role & Policy \u00b6 Create Policy \u00b6 vault policy write heqet-app << EOF path \"heqet/+/*\" { capabilities = [\"read\"] } EOF Add Auth Role \u00b6 vault write auth/kubernetes/role/heqet-app \\ bound_service_account_names=vault-secrets-operator \\ bound_service_account_namespaces=vault-secrets-operator \\ policies=heqet-app \\ ttl=6h Add Secrets \u00b6 Remember, Secret path: heqet/<APP-NAME>/<SECRET-NAME> vault kv put heqet/argocd/argocd-secret admin.password='$2y$12$FP8OlsVj5pOOqRAhI4XPoev1STaW01uUEZGcNPQtVZmpacebNhj9i' server.secretkey=\"pDYAWK2mHa68GwwVPAsQOsG/SUT8iIo3S3FXYUWf2qM=\" vault kv put heqet/loki-stack/loki-stack-grafana admin-user=admin admin-password='grafana' vault kv put heqet/pihole/pihole-admin password=pihole vault kv put heqet/minio/minio-secret secret-key=secret access-key=access Vault-Issuer Cert-Manager via Kubernetes Service Account \u00b6 We expect you already have setup a PKI & Intermediate PKI. You will need a policy to allow your approle to create new certs: And a role: [dc = my local domain] vault write pki_int/roles/dc \\ allowed_domains=.dc \\ allow_subdomains=true \\ max_ttl=72h Policy: vault policy write pki_int - <<EOF path \"pki_int*\" { capabilities = [\"read\", \"list\"] } path \"pki_int/roles/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/sign/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/issue/dc\" { capabilities = [\"create\"] } EOF Authorize Service Account vault write auth/kubernetes/role/vault-issuer \\ bound_service_account_names=vault-issuer \\ bound_service_account_namespaces=cert-manager \\ policies=pki_int \\ ttl=6h","title":"Vault"},{"location":"vault/#vault","text":"This are some quick notes I took on how to setup a simple Vault for usage with heqet. For a more detailed documentation on how to configure Vault, check out the Official Vault Docs . Note: Most of this commands can be executed either using the vault command on your local device or the inside the vault pod itself.","title":"Vault"},{"location":"vault/#init-vault-using-gpg","text":"","title":"Init Vault using GPG"},{"location":"vault/#copy-gpg-public-key","text":"cat > nold.pub << EOF -----BEGIN PGP PUBLIC KEY BLOCK----- mQENBGBXTjkBCAC7qZU1cz7RWYbAb838ypRLJZKLWfVBvry4XYwWPN0Rcj55dPN+ ... 5of4H66FzNwJxYrunmM5KTeUxZiLPC1JoKMF5uvKoo59TD0IuAPq735QDjWbS4vb dMtSqTCinZSd =wuZw -----END PGP PUBLIC KEY BLOCK----- EOF","title":"Copy GPG Public Key"},{"location":"vault/#init-vault","text":"vault operator init -key-shares=1 -key-threshold=1 -pgp-keys=\"nold.pub\"","title":"Init Vault"},{"location":"vault/#save-unseal-key-somewhere-sage-eg-keepass","text":"","title":"Save Unseal Key somewhere sage e.g. Keepass"},{"location":"vault/#decode-unseal-key","text":"$ echo $unseal-key | base64 -d | gpg -dq","title":"Decode Unseal Key"},{"location":"vault/#unseal-vault","text":"vault operator unseal","title":"Unseal Vault"},{"location":"vault/#enable-kubernetes-auth","text":"vault auth enable kubernetes vault write auth/kubernetes/config \\ token_reviewer_jwt=\"$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\ kubernetes_host=\"https://$KUBERNETES_PORT_443_TCP_ADDR:443\" \\ kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\ disable_iss_validation=true","title":"Enable Kubernetes Auth"},{"location":"vault/#create-secret-store","text":"vault secrets enable -path=heqet kv-v2","title":"Create Secret Store"},{"location":"vault/#add-secrets-operator-role-policy","text":"","title":"Add Secrets-Operator Role &amp; Policy"},{"location":"vault/#create-policy","text":"vault policy write heqet-app << EOF path \"heqet/+/*\" { capabilities = [\"read\"] } EOF","title":"Create Policy"},{"location":"vault/#add-auth-role","text":"vault write auth/kubernetes/role/heqet-app \\ bound_service_account_names=vault-secrets-operator \\ bound_service_account_namespaces=vault-secrets-operator \\ policies=heqet-app \\ ttl=6h","title":"Add Auth Role"},{"location":"vault/#add-secrets","text":"Remember, Secret path: heqet/<APP-NAME>/<SECRET-NAME> vault kv put heqet/argocd/argocd-secret admin.password='$2y$12$FP8OlsVj5pOOqRAhI4XPoev1STaW01uUEZGcNPQtVZmpacebNhj9i' server.secretkey=\"pDYAWK2mHa68GwwVPAsQOsG/SUT8iIo3S3FXYUWf2qM=\" vault kv put heqet/loki-stack/loki-stack-grafana admin-user=admin admin-password='grafana' vault kv put heqet/pihole/pihole-admin password=pihole vault kv put heqet/minio/minio-secret secret-key=secret access-key=access","title":"Add Secrets"},{"location":"vault/#vault-issuer-cert-manager-via-kubernetes-service-account","text":"We expect you already have setup a PKI & Intermediate PKI. You will need a policy to allow your approle to create new certs: And a role: [dc = my local domain] vault write pki_int/roles/dc \\ allowed_domains=.dc \\ allow_subdomains=true \\ max_ttl=72h Policy: vault policy write pki_int - <<EOF path \"pki_int*\" { capabilities = [\"read\", \"list\"] } path \"pki_int/roles/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/sign/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/issue/dc\" { capabilities = [\"create\"] } EOF Authorize Service Account vault write auth/kubernetes/role/vault-issuer \\ bound_service_account_names=vault-issuer \\ bound_service_account_namespaces=cert-manager \\ policies=pki_int \\ ttl=6h","title":"Vault-Issuer Cert-Manager via Kubernetes Service Account"},{"location":"addons/","text":"Addons \u00b6 Heqet contains a \"addon\" feature which will create additional resources for you or further simplefy configuration by abstraction.","title":"Addons"},{"location":"addons/#addons","text":"Heqet contains a \"addon\" feature which will create additional resources for you or further simplefy configuration by abstraction.","title":"Addons"},{"location":"addons/networkpolicy/","text":"NetworkPolicy \u00b6 NetworkPolicies allow you to control/deny access to or from your application. If you want to learn how NetworkPolices work, check out the Kubernetes documentation . Define Rules \u00b6 Next you can create/predefine NetworkPolices in resources/networkpolicy.yaml like this: networkrPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: [] rules: [] # NetworkPolices can be grouped: groups: [] # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress This rule will deny all out- [Egress] and Ingoing [Ingress] network traffic. We can define more rules ofcurse [even if 'deny-everything' is already included in 'allow-dns']: networkPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: - insecure rules: [] # NetworkPolices can be grouped: groups: insecure: - deny-everything - allow-dns # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {} This will create a group of both of our rules & apply them by default to all projects. Apply NetworkPolicies \u00b6 Finally we can apply the NetworkPolicy to our application project. Currently Heqet is not able to apply NetworkPolcies only to a single App of an project! from project.yaml : config: name: secure-project description: I like it secure! networkPolicy: rules: - deny-everything - allow-dns groups: - special-group apps: - name: my-secure-app [...] Allow communication between Heqet projects \u00b6 Here is a simple way to apply rules containing other heqet apps. Lets say we have two apps: config: name: project-one networkPolicy: rules: - deny-project-two apps: [...] So we want to deny access from project-one to project-two . In this case we can use a label that's automatically applied by heqet to every application namespace: app.heqet.gnu.one/project Our policy could look something like this: networkPolicy: rules: deny-project-two: podSelector: {} policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: app.heqet.gnu.one/project: project-two","title":"NetworkPolicy"},{"location":"addons/networkpolicy/#networkpolicy","text":"NetworkPolicies allow you to control/deny access to or from your application. If you want to learn how NetworkPolices work, check out the Kubernetes documentation .","title":"NetworkPolicy"},{"location":"addons/networkpolicy/#define-rules","text":"Next you can create/predefine NetworkPolices in resources/networkpolicy.yaml like this: networkrPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: [] rules: [] # NetworkPolices can be grouped: groups: [] # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress This rule will deny all out- [Egress] and Ingoing [Ingress] network traffic. We can define more rules ofcurse [even if 'deny-everything' is already included in 'allow-dns']: networkPolicy: # global config options config: # Generate NetworkPolicy to allow communication inside of the project namespace? # Only gets applied when other networkpolices are active on the project allowNamespace: true # policies that get applied by default defaults: groups: - insecure rules: [] # NetworkPolices can be grouped: groups: insecure: - deny-everything - allow-dns # Here are our policy definitions: rules: deny-everything: podSelector: {} policyTypes: - Egress - Ingress allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {} This will create a group of both of our rules & apply them by default to all projects.","title":"Define Rules"},{"location":"addons/networkpolicy/#apply-networkpolicies","text":"Finally we can apply the NetworkPolicy to our application project. Currently Heqet is not able to apply NetworkPolcies only to a single App of an project! from project.yaml : config: name: secure-project description: I like it secure! networkPolicy: rules: - deny-everything - allow-dns groups: - special-group apps: - name: my-secure-app [...]","title":"Apply NetworkPolicies"},{"location":"addons/networkpolicy/#allow-communication-between-heqet-projects","text":"Here is a simple way to apply rules containing other heqet apps. Lets say we have two apps: config: name: project-one networkPolicy: rules: - deny-project-two apps: [...] So we want to deny access from project-one to project-two . In this case we can use a label that's automatically applied by heqet to every application namespace: app.heqet.gnu.one/project Our policy could look something like this: networkPolicy: rules: deny-project-two: podSelector: {} policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: app.heqet.gnu.one/project: project-two","title":"Allow communication between Heqet projects"},{"location":"addons/repos/","text":"Repositories \u00b6 Heqet can add Helm & Git repositories to Argo-CD & resolve the repoURL in your config for you. Private repos are not supported [yet]. Configuration \u00b6 Here is a simple example of the configuration file resources/repos.yml : # Dict of helm or git repos we want to add to ArgoCD # Parameters: # name-of-repo: # url: https://... # type: [default: helm | git] # repos: bitnami: url: https://charts.bitnami.com/bitnami ## default: helm #type: helm heqet: url: https://git.nold.in/nold/heqet type: git Using Repos \u00b6 Here is a snipped from a project.yml : config: name: myproject apps: - name: myapp repo: bitnami chart: superappchart As you might guess, the option repo: bitnami gets resolved to the url in our repos configuration.","title":"Repositories"},{"location":"addons/repos/#repositories","text":"Heqet can add Helm & Git repositories to Argo-CD & resolve the repoURL in your config for you. Private repos are not supported [yet].","title":"Repositories"},{"location":"addons/repos/#configuration","text":"Here is a simple example of the configuration file resources/repos.yml : # Dict of helm or git repos we want to add to ArgoCD # Parameters: # name-of-repo: # url: https://... # type: [default: helm | git] # repos: bitnami: url: https://charts.bitnami.com/bitnami ## default: helm #type: helm heqet: url: https://git.nold.in/nold/heqet type: git","title":"Configuration"},{"location":"addons/repos/#using-repos","text":"Here is a snipped from a project.yml : config: name: myproject apps: - name: myapp repo: bitnami chart: superappchart As you might guess, the option repo: bitnami gets resolved to the url in our repos configuration.","title":"Using Repos"},{"location":"addons/vault/","text":"VaultSecret Generator \u00b6 The VaultSecret generator will create a VaultSecret for every secret specified in the secrets -hash. It's based on the vault-secret-operator . Parameters \u00b6 Parameter Type Example Description name string \"my-secret\" Name of Secret to generate & in vault [requited] keys array[string] - password Array of keys that will be pulled from the vault-secret [required] type string Opaque Secret type in Kubernetes [default: Opaque ] fromApp string myapp2 Pulls secret from another app, e.g. /heqet/<other-app>/<secret.name> . This way sharing secrets between apps is easily possible Examples \u00b6 Simple \u00b6 Here is an example for a simple secret: apps: - name: myapp secrets: - name: my-secret keys: - username - password # default: type: Opaque This will result in following resource. Notice that the path inside of Vault is /heqet/<name-of-app>/<name-of-secret> . apiVersion: ricoberger.de/v1alpha1 kind: VaultSecret metadata: name: my-secret namespace: \"myapp\" labels: app: myapp annotations: argocd.argoproj.io/sync-wave: \"-1\" spec: keys: - username - password path: heqet/myapp/my-secret type: Opaque Sharing Secrets between Apps \u00b6 Secrets can also be shared & pulled from other apps, by using the fromApp parameter: apps: - name: myapp secrets: - name: my-secret keys: - username - password - shared-key # default: type: Opaque - name: myapp2 secrets: - name: my-secret fromApp: myapp keys: - shared-key","title":"VaultSecret Generator"},{"location":"addons/vault/#vaultsecret-generator","text":"The VaultSecret generator will create a VaultSecret for every secret specified in the secrets -hash. It's based on the vault-secret-operator .","title":"VaultSecret Generator"},{"location":"addons/vault/#parameters","text":"Parameter Type Example Description name string \"my-secret\" Name of Secret to generate & in vault [requited] keys array[string] - password Array of keys that will be pulled from the vault-secret [required] type string Opaque Secret type in Kubernetes [default: Opaque ] fromApp string myapp2 Pulls secret from another app, e.g. /heqet/<other-app>/<secret.name> . This way sharing secrets between apps is easily possible","title":"Parameters"},{"location":"addons/vault/#examples","text":"","title":"Examples"},{"location":"addons/vault/#simple","text":"Here is an example for a simple secret: apps: - name: myapp secrets: - name: my-secret keys: - username - password # default: type: Opaque This will result in following resource. Notice that the path inside of Vault is /heqet/<name-of-app>/<name-of-secret> . apiVersion: ricoberger.de/v1alpha1 kind: VaultSecret metadata: name: my-secret namespace: \"myapp\" labels: app: myapp annotations: argocd.argoproj.io/sync-wave: \"-1\" spec: keys: - username - password path: heqet/myapp/my-secret type: Opaque","title":"Simple"},{"location":"addons/vault/#sharing-secrets-between-apps","text":"Secrets can also be shared & pulled from other apps, by using the fromApp parameter: apps: - name: myapp secrets: - name: my-secret keys: - username - password - shared-key # default: type: Opaque - name: myapp2 secrets: - name: my-secret fromApp: myapp keys: - shared-key","title":"Sharing Secrets between Apps"},{"location":"config/application/","text":"Application Config \u00b6 Required \u00b6 Parameter Type Example Description name string \"argocd\" Name of your application & namespace [if not specified] repoURL string \"https://github.com/nold360/heqet\" URL to git or Helmchart repo or repo string \"heqet\" Name of a predefinied Helm/Git-Repo path string \"charts/heqet\" Path to chart if using git as source repo chart string \"heqet\" Chart name [ only use either path or chart ] targetRevision string \"1.2.3\" or \"master\" Version of Helm-Chart or Branch/Tag of git Optional \u00b6 Parameter Type Default Example Description existingNamespace string none \"default\" Don't create namespace, instead use an existing one namespace string Namespace of project \"superns\" Name of application namespace annotations hash my.anno.org/stuff: is-awesome Kubernetes Resource annotations syncWave string \"0\" `\"-2\" ArgoCD SyncWave server string \"https://kubernetes.default.svc\" https://my.external.cluster:8443 K8s Cluster to deploy to automated.prune bool false true ArgoCD automatic prune app automated.selfHeal bool false true ArgoCD automatic self-heal app ignoreDiff array See ArgoCD docs ArgoCD ignoreDifferences parameters array - name: ingress.host value: awesome.url Parameters override values of app include array - value-snippet Include a values snippet from resources/snippets Full Example \u00b6 Check out the hive -Branch of this repo for my current homelab setup.","title":"Application Config"},{"location":"config/application/#application-config","text":"","title":"Application Config"},{"location":"config/application/#required","text":"Parameter Type Example Description name string \"argocd\" Name of your application & namespace [if not specified] repoURL string \"https://github.com/nold360/heqet\" URL to git or Helmchart repo or repo string \"heqet\" Name of a predefinied Helm/Git-Repo path string \"charts/heqet\" Path to chart if using git as source repo chart string \"heqet\" Chart name [ only use either path or chart ] targetRevision string \"1.2.3\" or \"master\" Version of Helm-Chart or Branch/Tag of git","title":"Required"},{"location":"config/application/#optional","text":"Parameter Type Default Example Description existingNamespace string none \"default\" Don't create namespace, instead use an existing one namespace string Namespace of project \"superns\" Name of application namespace annotations hash my.anno.org/stuff: is-awesome Kubernetes Resource annotations syncWave string \"0\" `\"-2\" ArgoCD SyncWave server string \"https://kubernetes.default.svc\" https://my.external.cluster:8443 K8s Cluster to deploy to automated.prune bool false true ArgoCD automatic prune app automated.selfHeal bool false true ArgoCD automatic self-heal app ignoreDiff array See ArgoCD docs ArgoCD ignoreDifferences parameters array - name: ingress.host value: awesome.url Parameters override values of app include array - value-snippet Include a values snippet from resources/snippets","title":"Optional"},{"location":"config/application/#full-example","text":"Check out the hive -Branch of this repo for my current homelab setup.","title":"Full Example"},{"location":"config/project/","text":"Project Definition \u00b6 Here is a list of available configuration options inside the apps array of heqets values.yaml . Project Config \u00b6 Project configuration parameters will be merged into application parameters. So basically all application parameters can be used here. Special project parameters: Parameter Type Default Example Description name string Name of project directory my-project Name of project in Argo-CD namespace string Name of project myspace Name of default Namespace of projects apps description string None \"My great project\" Description of project in Argo-CD networkPolicy dict None See addons/networkpolicy","title":"Project Definition"},{"location":"config/project/#project-definition","text":"Here is a list of available configuration options inside the apps array of heqets values.yaml .","title":"Project Definition"},{"location":"config/project/#project-config","text":"Project configuration parameters will be merged into application parameters. So basically all application parameters can be used here. Special project parameters: Parameter Type Default Example Description name string Name of project directory my-project Name of project in Argo-CD namespace string Name of project myspace Name of default Namespace of projects apps description string None \"My great project\" Description of project in Argo-CD networkPolicy dict None See addons/networkpolicy","title":"Project Config"}]}